use crate::{AeroBody,AirState,WindModel,DensityModel};
use crate::types::{Vector3,Frame,Force,Torque};

use crate::types::{Float,DefaultFloatRepr};

/// Trait for aerodynamic effect
pub trait AeroEffect<I = Vec<DefaultFloatRepr>, T: Float = DefaultFloatRepr> {
    /// Return `Force` and `Torque` generated by the effect.
    /// 
    /// When this effect is given to an [AffectedBody], `get_effect` will be called at each timestep
    /// to get the force and torque induced by the effect. The returned Force and Torque are
    /// typically body frame, but this is not required.
    /// 
    /// # Arguments
    /// * `airstate` - The vehicle airstate at the current timestep
    /// * `rates` - The body axis rates at the current timestep \[roll,pitch,yaw\] (rad/s)
    /// * `inputstate` - A reference to the inputstate passed to [AffectedBody::step]
    fn get_effect(&self, airstate: AirState<T>, rates: Vector3<T>, inputstate: &I) -> (Force<T>,Torque<T>);
}

use crate::wind_models::ConstantWind;
use crate::aero::StandardDensity;

/// Represent a body subject to aerodynamic effects
pub struct AffectedBody<I = Vec<DefaultFloatRepr>, T: Float = DefaultFloatRepr, W: WindModel<T> = ConstantWind<T>, D: DensityModel<T> = StandardDensity> {
    /// Underlying AeroBody
    pub body: AeroBody<T,W,D>,
    /// Vec of aerodynamic effects
    pub effectors: Vec<Box<dyn AeroEffect<I,T>>>,
}

impl<I, T: Float, W: WindModel<T>, D: DensityModel<T>> AffectedBody<I,T,W,D> {
    /// Calculate the state derivative
    /// 
    /// NB: Gravity is included by default
    /// 
    /// # Arguments
    /// * `state` - 13-dimensional state vector to get derivative about
    /// * `inputstate` - The input state to pass to the suplied [AeroEffect]s
    pub fn get_derivative(&self, state: &StateVector<T>, inputstate: &I) -> StateVector<T> {
        let airstate = self.body.get_airstate();
        let rates = self.body.rates();
        let ft_pairs = self.effectors.iter().map(|e| e.get_effect(airstate,rates,inputstate) );
        
        let mut forces = Vec::<Force<T>>::with_capacity(self.effectors.len());
        let mut torques = Vec::<Torque<T>>::with_capacity(self.effectors.len());
        for (f,t) in ft_pairs {
            forces.push(f);
            torques.push(t);
        }
        
        self.body.get_derivative(state, &forces, &torques)
    }
    
    /// Propagate the system state by delta_t with `inputstate`
    /// 
    /// NB: Forces and Torques are calculated at the beginning of the timestep and are not recalculated
    /// as part of the Runge-Kutta iteration.
    /// 
    /// # Arguments
    /// * `delta_t` - The timestep for this step
    /// * `inputstate` - The input state to pass to the suplied [AeroEffect]s
    pub fn step(&mut self, delta_t: T, inputstate: &I) {
        let airstate = self.body.get_airstate();
        let rates = self.body.rates();
        let ft_pairs = self.effectors.iter().map(|e| e.get_effect(airstate,rates,inputstate) );
        
        let mut forces = Vec::<Force<T>>::with_capacity(self.effectors.len());
        let mut torques = Vec::<Torque<T>>::with_capacity(self.effectors.len());
        for (f,t) in ft_pairs {
            forces.push(f);
            torques.push(t);
        }
        
        self.body.step(&forces,&torques,delta_t);
    }
   
    /// Get body acceleration in previous timestep
    /// 
    /// See [Body::acceleration](crate::Body::acceleration) for more details
    pub fn acceleration(&self) -> Vector3<T> {
        self.body.acceleration()
    }
    
    /// Set the statevector for the underlying [AeroBody]
    /// 
    /// This in turn sets the statevector for the underlying [Body]
    /// 
    /// The statevector is in the order: \[position,velocity(body),attitude_quaternion(i,j,k,w),axis_rates(body)\]
    pub fn set_state(&mut self, new_state: StateVector<T>) {
        self.body.set_state(new_state);
    }
    
    /// Return the current airstate for the rigid body
    /// See documentation for [AeroBody::get_airstate]
    pub fn get_airstate(&self) -> AirState<T> {
        self.body.get_airstate()
    }
    
}

use crate::types::{UnitQuaternion,StateVector,StateView};
impl<I, T: Float, W: WindModel<T>, D: DensityModel<T>> StateView<T> for AffectedBody<I,T,W,D> {
    fn position(&self) -> Vector3<T> {
        self.body.position()
    }
    
    fn velocity_in_frame(&self, frame: Frame) -> Vector3<T> {
        self.body.velocity_in_frame(frame)
    }
    
    fn attitude(&self) -> UnitQuaternion<T> {
        self.body.attitude()
        }
    
    fn rates_in_frame(&self, frame: Frame) -> Vector3<T> {
        self.body.rates_in_frame(frame)
    }
    
    fn statevector(&self) -> StateVector<T> {
        self.body.statevector()
    }
}